## 2021_12_09

## 3장 자바스크립트 기초

<h3>변수 선언</h3>

자바스크립트는 정적 타입 언어와는 다르게 **느슨한 타입(loose typing)** 을 가진 언어이기 때문에 데이터 타입을 명시하지 않고 변수를 선언할 수 있다.

`느슨한 타입이라고 타입이 존재하지 않는 것은 아니다. 내부적으로는 데이터의 종류에 따른 변수의 타입을 가진다.`

---

<h4> var </h4>

var 키워드로 변수를 선언하는 것은 ES2015(ES6)에서 let 과 const가 등장하기 전까지 유일한 방법이었습니다. var로 선언된 변수는 기존 값을 덮어쓰며, 함수 스코프를 기준으로 동작한다.

~~~
var a = 1;

if (isSomething())  {
  var a = 2;
}
console.log(a); // 2
~~~

var로 변수를 선언한 경우 스코프 내에 이미 동일한 식별자를 가진 변수가 존재한다면 해당 변수에 값을 재할당한다. 값을 덮어쓰는 경우가 있어 다른 코드에 영향을 주거나 버그가 발생 시 찾기가 힘들다.

블록 또는 함수 스코프내에서 선언한 것이 아니라면 변수는 전역 스코프를 가짐. 이를 전역 변수라고 한다. 

변수가 함수 스코프를 가진다는 것은 **변수를 선언한 함수 몸체 안에서만 해당 변수에 접근이 가능하다는 의미** 이다.


<h4>let과 const</h4>

let과 const는 ES2015에서 등장한 변수 선언 키워드이다. 재선언을 허용하지 않으며, 함수 스코프가 아닌 블록 스코프를 가진다.

const는 let과 달리 값 변경이 아예 불가능하다는 차이가 있다.

자바스크립트 진영에서는 var보다는 let과 const를 사용하라고 권장하고 있다.

---
<h3>객체와 타입</h3>

자바스크립트의 값은 원시 타입(Primitive Type)과 객체(참조형)로 나뉜다. 원시 타입은 다음과 같이 7가지가 있다.

- number, string, boolean, null, undefined, Symbol, BigInt(ES2020에서 추가)

원시 타입은 하나의 값만 가지며, 불변 데이터이기 때문에 연산을 해도 기존 데이터는 변하지가 않는다. 

원시 타입을 제외한 나머지는 모두 객체이다. 배열, 함수, 정규식 등 전부다 객체에서 파생된 특수한 타입이다.

---

<h4> number </h4>

JS의 숫자 타입은 저수, 실수 구분 없이 숫자 타입 한 가지만 존재한다. 숫자 타입은 모든 데이터를 64비트의 부동 소수점 형태로 저장하기 때문에 진정한 정수 데이터는 존재하지 않음.

<h4> NaN </h4>

JS에는 NaN이라는 특별한 속성이 존재함. Not A Number라는 값이며 읽기 전용 속성이다. 숫자로 변환할 수 없는 값을 숫자로 변환하려고 하거나 산술 연산의 결과가 숫자가 아니면 NaN값이 반환 된다.

NaN은 자기 자신과도 동등하지 않은 결과를 반환하기 때문에 Number.isNaN() 함수를 사용해서 판별하기 바란다.

<h4> 소수점 연산 </h4>

JS에서 널리 알려진 소수점 연산의 문제점이 있다.
`0.1 + 0.2 === 0.3 // false`
정확한 값이 아닌 근삿값 연산이기 때문에 답은 false이다. 이러한 문제는 Number.EPSILON을 사용해 해결이 가능하다.

정밀한 소수점 연산 또는 굉장히 큰 단위의 연산이 필요하지 않다면 JS의 연산은 믿고 사용해도 된다.

---

<h4> string </h4>

string은 텍스트를 표현하는 타입이다. js의 문자열은 리터럴 형태로 주로 사용하며, 홑따옴표, 쌍따옴표, 백틱(``)을 이용해 표현함.

js의 문자열은 16비트의 유니코드 문자 집합을 연속적으로 나열한 것이다.

<h4> 이스케이프 </h4>

문자열을 사용하다 보면 홑따옴표 또는 쌍따옴표를 텍스트 데이터로 표현해야 할 때가 있습니다. 이럴때는 역슬래시(\) 문자로 이스케이프 처리해 사용한다.

- \n : 줄바꿈 문자, \r : 캐리지 리턴, \t : 수평 탭, \v : 수직 탭, \f : 폼 피드

<h4> 템플릿 리터럴 </h4>

ES2015의 템플릿 리터럴이 등장하면서, 문자열 내의 변수나 상수를 간결하게 표현할 수 있게 되었다. 달러 기호와 중괄호(${})로 표현식을 감싸 문자열 안에 그값을 삽입할 수 있다.

~~~
const name = 'javascript';
cost sentence = 'I love the &{name}';
~~~

---

<h4> boolean </h4>

불리언 타입은 true, false 두 가지 값만을 가지며 참과 거짓을 표현할 때 사용한다. 

<h4> null과 undefined </h4>

null은 값이 없음을 나타내는 특별한 타입이다. 대다수 언어에서 값이 없음을 나타내고 싶을 때 null 타입을 사용한다. 하지만 js에는 값이 없음을 나타내는 또 다른 타입인 undefined가 있다. 값이 할당되지 않는 변수나 반환 값이 없는 함수의 결과값은 자동으로 undefined가 할당된다. 

여기서 팁으로 알려주는 것은 의도적으로 값이 없음을 나타내고 싶을 때는 null을 사용하고, 값이 할당되지 않음을 나타내고 싶을 때는 undefined를 할당한다. 

---

<h4> Symbol </h4>

심볼은 Es2015에서 도입된 원시 타입이다. 데이터의 유일함을 나타낼 때 사용하며, 생성된 심볼은 다른 어떤 심볼과도 일치하지 않는다. 

<h4> 전역 심볼 </h4>

전역 심볼을 생성해 매번 새로운 심볼을 생성하지 않고 기본 심볼을 검색해 사용하기도 한다. Symbol.for() 메서드를 사용하면 전역 심볼을 생성하며, 사용할 때는 다른 라이브러리와 충돌을 피하도록 prefix를 사용해 구분하는 것이 좋다.

<h4> 심볼의 활용 </h4>

심볼은 객체나 클래스에서 유일한 프로퍼티를 만들 때 사용한다. 심볼을 사용해 프로퍼티를 만들면 유일함이 보장되어 프로퍼티 추가 시 충돌이 날 염려가 없다. 또한 외부에서 직접 해당 프로퍼티에 접근 할 수가 없어 의도치 않은 프로퍼티 변경을 막을 수 있다.

~~~
const user = {
  name : 'javascript'
};
const id = Symbol('id');
user[id] = 'firstId';
// 심볼은 유일한 값이라 외부에서 직접 프로퍼티에 접근 x
console.log(user[Symbol('id')]); // undefined
~~~

---

<h3>객체</h3>

js에서 원시 타입이 아닌 모든 값은 객체이다. 객체는 **이름(키):값** 형태로 여러 값을 포함하는 컨테이너이며, 내부의 값은 얼마든지 변경이 가능하다. 이름에 해당하는 프로퍼티 명은 숫자와 문자열, 심볼만 가능하며 값에 해당하는 프로퍼티는 어떤 표현식이든 올 수가 있다.

<h4> 객체의 생성 </h4> 

객체를 생성하는 방법은 세 가지이다. Object() 생성자 함수를 사용하는 방법, 객체 리터럴({})을 사용하는 방법, 직접 정의한 생성자 함수를 사용하는 방법이다.


Object()는 객체를 생성하도록 js에 내장된 생성자 함수이다. 하지만 뒤에 설명할 객체 리터럴을 사용해 생성하는 것이 훨씬 간결하기 때문에 거의 사용되지 않는 편이다.

<h4> 객체 리터럴 </h4>

중괄호를 사용해 객체를 생성하는 강력한 문법이다. 이름 : 값 형태로 프로퍼티 이름과 값을 중괄호 안에 정의해 객체를 생성한다

~~~
const obj = {
  name : 'name',
  id : 'id'
};
~~~

객체리터럴은 간단한 문법으로 객체 생성과 동시에 프로퍼티까지 추가가 가능해서 가장 많이 사용되는 방법이다.

<h4> 생성자 함수 </h4>

js에서 생성자 함수는 형식이 정해져 있지 않습니다. 함수를 선언해 new 키워드를 사용해 호출하면 해당 함수는 생성자 함수로 동작한다.

하지만 모든 함수를 생성자 함수로 사용하지 않기때문에 일반함수와 생성자 함수를 구분하기 위해 **생성자 함수 이름의 첫 글자를 대문자로 표기** 하는 것을 권장함.

~~~
function Vehicle(type){
  this.type = type;
}
const car = new Vehicle('Car');  // {type: 'Car'}
~~~

<h4> 객체의 프로퍼티 읽기 </h4>

객체의 프로퍼티는 점 표기법 또는 대괄호 표기법으로 접근한다. 

~~~
obj.name;
obj.age;
obj.child.name;

obj['name'];
obj['age'];
~~~

대부분은 점 표기법을 많이 사용하지만 대괄호 표기법을 사용해야만 접근 가능한 경우가 있다. 변수를 사용해 프로퍼티에 접근하거나 접근하려는 프로퍼티 명에 연산자가 포함된 경우에는 반드시 대괄호 표기법을 사용해야한다.

~~~
const prop = 'name';
obj[prop];
obj[last-name];
~~~

두 표기법 모두 객체에 존재하지 않는 프로퍼티에 접근할 경우 undefined를 반환함.

<h4> 동적 프로퍼티 생성과 갱신 </h4>

js의 객체는 생성된 후에도 동적으로 프로퍼티를 생성하거나 갱신이 가능하다. 프로퍼티가 존재한다면 갱신하고 존재하지 않는다면 추가한다.

<h4> getter와 setter </h4>

어떤 프로퍼티에 접근할 때마다 동적인 계산이 필요하거나 프로퍼티 값이 변경될 때마다 처리 코드가 필요한 경우에 getter와 setter 접근자 프로퍼티를 사용해 일반 프로퍼티처럼 사용이 가능하다. 접근자 프로퍼티의 값에 접근하면 getter 메서드가 호출되며 변경하려고 하면 setter 메서드가 호출이 된다.

~~~
const obj = {
  myName : 'js',
  set name(name){
    if (name !== null){
      this.myName = name;
    }
  },
  get name() {
    return this.myName;
  } 
}
~~~

접근자 프로퍼티를 정의하는 가장 간단한 방법은 객체 리터럴 문법을 사용하는 것이다. get/set 문법을 사용해 정의하며, 프로퍼티의 값을 갱신할 때 유효성을 검증하거나, 조건에 따라 다른 값을 반환하는 작업을 할 때 사용한다.

<h4> Object.defineProperty()와 속성 </h4>

접근자 프로퍼티를 생성하는 또 다른 방법은 정적 메서드 Object.defineProperty()를 사용하는 것이다. 이 메서드는 객체에 직접 새로운 프로퍼티를 정의하거나 이미 존재하는 프로퍼티를 수정한 후 그 객체를 반환한다.

~~~
cosnt obj = {myName : 'js'};

Object.defineProperty(obj,'name',{
  set(name) {
    if (name !== null){
      this.myName = name;
    }
  },
  get() {
    return this.myName;
  }
});
~~~

이 메서드는 첫 번째 인자로 대상이 되는 객체, 두 번째 인자로 추가 또는 갱신하려는 프로퍼티명이나 심볼을 넘긴다. 그리고 마지막 인자로 프로퍼티 서술자를 정의한 객체를 넘긴다. getter와 setter를 포함해 여러 서술자들이 존재.

---

<h3> 배열 </h3>

배열은 객체의 특별한 형태로 순서가 있는 데이터의 집합이다. 인덱스는 0부터 시작하는 정수이다. 

<h4> 배열의 생성 </h4>

배열은 Array() 생성자 함수나 배열 리터럴([])을 사용해 생성한다.

객체와 마찬가지로 배열도 js에 내장된 생성자 함수 Array()가 있으며, 이를 사용해 배열을 생성할 수 있다.

~~~
cosnt arr = new Array(1,'2',true);

const arr2 = new Array(3);
console.log(arr2); // [empty,empty,empty]
~~~

Array()생성자 함수는 새로운 배열을 생성하고 인자로 받은 값들을 배열 원소로 채워 넣어 초기화 한다. 만약 생성자 함수의 인자가 1개이고 숫자 값이라면 해당 값을 배열의 length 프로퍼티에 할당해 새로운 배열을 생성함.

하지만 Array() 생성자 함수 역시 배열 리터럴 문법이 더 간단하여 잘 사용하지 않음.

<h4> 배열 리터럴 </h4>

배열 리터럴은 대괄호를 사용하낟. js에는 배열 안의 원소들의 타입이 달라도 되는데 이것을 비균질적 배열이라고 한다. 하지만 이런 배열 데이터는 일관성 있게 처리하기 힘들어 가급적 실제 배열 데이터는 통일된 타입의 데이터를 사용 하는 것이 좋다.

<h4> 원소 접근과 동적인 원소 생성 </h4>

배열 원소는 대괄호안에 인덱스 값을 넣어 접근한다. 만약 배열 길이보다 큰 인덱스값을 넣어 접근한다면 값이 할당되지 않아 undefined를 반환함.

배열도 객체이기 때문에 동적으로 배열 원소를 추가할 수 있다. 특히 js의 배열은 순차적으로 값을 넣지 않아도 된다. 이때 값을 추가한 인덱스의 위치에 따라 length 프로퍼티도 갱신된다. **배열의 length 프로퍼티는 항상 최대 인덱스보다 크기 때문이다**

<h4> 희소 배열 </h4>

배열의 중간 원소가 비어있는 배열을 뜻 한다. 희소 배열의 빈 원소는 forEach(), map(), filter()와 같은 배열의 내장 메서드에서 무시된다. 반면 find(),findIndex() 메서드는 빈 원소를 무시하지 않고 모두 탐색하기 때문에 일관적이지 않은 동작을 수행한다.
코드 가독성이나 데이터 구조 파악에도 좋지 않으니 특수한 경우를 제외하고는 사용을 지양해야한다.

