# 2022_01_02

JS 객체의 프로퍼티나 메서드에 접근하는 원리에 대해 알아보고, 상속을 구현하고, 스코프의 정의와 규칙, 모듈, 클로저, 호이스팅에 대해 배우는 단원

---

<h2> 프로토타입 </h2>

Js에서는 프로토타입을 기반으로 객체 지향의 상속 개념을 구현한다. **모든 객체는 부모 역할을 하는 프로토타입 객체의 참조 링크를 가지고 있고, 이걸 통해 프로퍼티나 메서드를 상속 받을 수 있다** 또한 프로토타입도 상위 프로토타입으로부터 프로퍼티나 메서드를 상속 받을 수 있다.

<h3> 프로토타입과 프로토타입 체인 </h3>

객체의 프로토타입은 참조 링크 형태로 [[Prototype]] 내부 프로퍼티에 저장된다. **참조 링크 형태의 저장이므로 동일 프로토타입 상속 객체는 모두 같은 프로퍼티와 메서드를 공유함**


<h4> 프로토타입 체인 </h4>

프로토타입 체인은 상위 프로토타입과 연쇄적으로 연결되 구조를 의미함 그리고 프로퍼티나 메서드에 접근하기 위해 이 연결구조를 따라 차례대로 검색하는 것을 프로토타입 체이닝이라고 한다.

<h4> 최상위 프로토타입 </h4>

Object.prototype은 프로토타입 체인의 최상위 프로토타입이다. 모든 객체의 종점이기도 하다.

<h4>다양한 객체의 프로토타입</h4>

배열처럼 내장된 객체의 프로토타입은 각자 자신의 프로토타입을 따로 정의 하고 있다. 배열 객체는 프로토타입으로 Array.prototype 이란 고유 객체가 설정된다.

물론 Array.prototype의 상위는 Objetct.prototype이다.

---

<h3> 프로토타입과 생성자 함수 </h3>

모든 함수에는 **prototype** 프로퍼티가 존재함. new 키워드와 함께 생성자 함수로 사용할 경우에는 특별한 역할을 한다

여기서 구분해야 할 점은 객체의 [[Prototype]]과 함수의 prototype은 다르다는 점이다 함수의 prototype은 일반적인 객체의 프로퍼티이며, 프로토타입을 가리키는 참조링크는 아니다.

<h4>객체의 생성과 함수의 prototype 프로퍼티</h4>

생성자 함수로 생성된 객체는 '생성자 함수의 prototype 프로퍼티'가 프로토타입([[Prototype]])으로 설정 된다.

~~~
function Vehicle(type) {
  this.type = type;
}

const vehicle = new Vehicle('Car');
console.log(Vehicle.prototype === vehicle.__proto__); // true
~~~

vehicle 객체의 프로토타입은 Vehicle() 생성자 함수의 Vehicle.prototype을 가리키며 이것은 Object.prototype을 가리킨다.

생성자 함수를 통해 생성된 모든 객체는 이러한 매커니즘으로 상속을 구현함.

<h4> 함수의 prototype 프로퍼티와 프로토타입의 관계</h4>

함수의 prototype 프로퍼티는 constructor 프로퍼티 하나만을 가지는 객체이다. 이 프로퍼티는 자신과 연결된 생성자 함수를 가리키며, 이 프로퍼티를 통해 객체가 어떤 생성자 함수를 통해 생성되었는지 알 수 있다.

즉 생성자 함수와 생성자 함수의 prototype 프로퍼티는 서로 상호 참조 관계이다.

---

<h3> 프로토타입의 확장과 상속 </h3>

프로토타입에 메서드나 프로퍼티를 추가하는 방법도 Js의 객체이므로 일반 객체처럼 동적으로 프로퍼티나 메서드를 추가하거나 삭제할 수 있다. 이렇게 변경된 프로퍼티는 실시간으로 프로토타입 체인을 통한 검색에 반영이 된다.

~~~
function Vehicle(type) {
  this.type = type;
}

Vehicle.prototype.stop = function() {
  console.log('stop!');
}

const vehicle = new Vehicle('car');
console.log(vehicle.stop()); // 'stop!'
~~~

단, 객체가 생성된 이후에 프로토타입을 수정하는 것은 지양해야한다.

<h4> 프로토타입을 사용한 상속 구현 </h4>

~~~
function inherit(Parent,child){
  function F() {};
  F.prototype = Parent.prototype;
  child.prototype = new F();
  child.prototype.constructor = child;
}
~~~

F의 프로토타입으로 부모의 프로토타입을 가리키게 하였고, 차일드의 프로토타입에 F()를 넣어 체이닝이 되게끔 하였다. 마지막으로 차일드 프로토타입의 constructor에 child를 넣어 줌.

특정 vehicle 객체의 프로퍼티나 메서드를 상속받고 싶은게 아니므로, F() 생성자 함수를 사용하여 부모 클래스의 인스턴스와 자식 클래스의 인스턴스를 독립적으로 만들어 사용하는 것입니다.

<h4> 생성자 빌려 쓰기 </h4> 

아직 한 가지의 문제가 존재한다. Car 클래스의 인스턴스를 생성할 때 부모 클래스인 Vehicle() 생성자 함수가 호출되지 않는 것이다. 이 문제는 Car() 생성자 함수에서 apply() 메서드를 사용하여 해결할 수 있습니다.

~~~
function Car(type) {
  Vehicle.apply(this,arguments);
  this.type = type;
}
~~~

apply() 메서드를 사용하여 Vehicle() 생성자 함수의 첫 번째 인자로 Car() 생성자 함수에서 생성된 객체를 전달함. 이렇게 하면 새로 생성된 객체로 this 바인딩이 변경되기 때문에 Vehicle() 생성자 함수에서 이 객체를 대상으로 동작을 수행한다. 이러한 방식으로 자식 클래스의 인스턴스를 생성할 때 부모 클래스의 생성자를 호출하는 것을 **생성자 빌려쓰기**라고 한다.

여기서는 상속 과정을 보여주었으나, Object.create(), Object.setPrototypeOf() 메서드를 사용해서 더 쉽게 객체의 프로토타입을 지정할 수 있다.

<h3> Class </h3>

Js의 클래스와 상속은 생성자 함수와 프로토타입을 사용하여 구현할 수 있다. 하지만 직관적이지 않고 번거로운 면이 존재함. 이를 해결하기 위해 ES2015에서 class 키워드를 이용한 새로운 문법이 등장하였다. 문법적 설탕(Syntactic sugar)로 좀 더 편하고 세련되게 클래스와 상속을 구현할 수 있게 해줌.

> Note. 문법적 설탕이란 간결한 표현으로 사람이 더 이해하기 쉽도록 고안된 문법을 의미합니다. Js에서는 class 문법과 async, await 문법이 이에 해당한다

~~~
class Vehicle{
  constructor() {
    console.log('hi');
  }
  run() {
    console.log('run');
  }
  stop() {
    console.log('stop');
  }
}
console.log(new Vehicle());
~~~

class 문법을 사용하여 선언한 클래스 역시 함수이다. 

<h4> 상속 </h4>

class 문법을 사용하면 상속을 간단하게 구현할 수 있다.

~~~
class Car extends Vehicle {
  constructor(type){
    super();
    this.type = type;
  }
}
~~~

extends 키워드 뒤 상속받을 부모 클래스만 정의한 후 , constructor 생성자 메서드에서 super()를 호출하면 된다.

extends 키워드로 특정 클래스를 상속받는 경우에는 cosntructor() 생성자 메서드에서 반드시 this를 사용하기 전에 super()를 호출해야 한다. 부모 클래스의 constructor() 메서드에서 반환한 객체를 자식 클래스에서 사용하기 때문이다.

<h4>정적 메서드와 private 접근 제한자 </h4>

class 문법에서는 static 키워드를 사용하여 정적 메서드를 정의할 수도 있다. 정적 메서드는 특정 인스턴스에 묶이는 것이 아니기 때문에 this가 아닌 클래스 이름을 사용하여 접근이 가능하다. 정적 메서드는 특정한 형태의 인스턴스를 생성하는 팩토리 함수를 정의할 때 많이 사용된다.

~~~
static CreateSuv() {
  return new Car('SUV');
}
~~~

<h4>private 접근 제한자</h4>

클래스의 프로퍼티와 메서드는 기본 public이기 때문에 외부 수정이 가능하다. TC39에서는 이를 보완하기 위해 #prefix를 추가해 private 클래스 필드를 선언하는 명세 작업을 진행중이다.
~~~
class Car extends Vehicle{
  #name;

  constructor(type){
    super();
    this.type = type;
    this.#name = 'mycar';
  }
}
~~~
---

<h2> 스코프(scope) </h2>

**스코프는 변수나 매개변수에 접근할 범위를 결정함** Js의 스코프는 함수와 블록 단위의 스코프로 나눌 수 있으며, 중첩된 스코프가 정의될 수도 있다.

<h3> 함수 스코프와 블록 스코프 </h3>

함수 스코프는 말 그대로 선언되 함수 단위로 생성되는 스코프이다.

~~~
function foo() {
  if(ture) {
    var a = 1;
  }
  console.log(a) // 1
}
foo();
~~~

변수 a를 블록 안에 선언하였지만 var는 함수 스코프를 따라가므로 조건문 블록을 무시하고 함수 몸체 안에서 접근이 가능하다. 하지만 외부에서 조건문 안의 변수에 접근하는 경우는 대부분 없을것이고, 직관적이지 않기 때문에 지양해야한다.

<h4> 블록 스코프와 let, const </h4>

블록 스코프에서는 변수의 유효 범위를 블록({})단위로 제한하여 사용이 가능하다. let과 const는 블록 스코프를 따른다.

~~~
function foo() {
  if(true){
    const a = 1;
  }
  console.log(a) // ReferenceError
}
foo();
~~~

const 키워드를 사용해 선언한 변수 a는 블록 안에서만 유효하다. 이는 훨씬 직관적이고 명료하다.

<h3> 렉시컬 스코프 </h3>

언어의 스코프는 대부분 동적 스코프와 렉시컬 스코프 두 가지 방식으로 동작한다. 동적 스코프는 런타임 중 함수의 호출에 의해 결정되고, **렉시컬 스코프는 변수나 함수를 어디에 작성하였는가에 기초하여 결정된다** 

스코프는 함수를 어디서 작생했는가에 따라 명확한 경계를 가지며, 동일한 경계를 가진 스코프는 존재할 수 없다. 즉 렉시컬 스코프 규칙에 따라 스코프의 경계가 결정되는 것이다.

~~~
function foo() {
  var a = 1;
  function bar(b) {
    console.log(a,b); // 1,2
  }
  bar(2);
}
foo();
~~~

3개의 스코프가 중첩되어 있는 예제로 변수 a를 스코프에서 어떻게 검색하는지 살펴보겠습니다.

1. console.log() 메서드에서 참조된 변수 a를 찾기 위해 bar() 함수의 스코프부터 검색을 시작합니다.
2. bar() 함수의 스코프에는 변수 a를 찾을 수 없으므로 가장 가까운 상위 스코프 foo() 함수 스코로 올라가 검색함.
3. foo() 함수 스코프에서 변수 a를 찾아 사용하며, 검색은 여기서 중단된다.

중요한 점은 안쪽부터 상위로 올라가며 검색하기 때문에 상위 스코프에서 안쪽 스코프의 변수나 함수에는 접근 할 수 없다는 점이다

이러한 스코프들의 연결관계를 스코프 체인이라고 하며, 스코프 체인을 따라 검색하는 과정을 스코프 체이닝 이라고 한다

**함수 스코프와 블록 스코프는 스코프의 단위이며, 렉시컬 스코프는 이 스코프들의 범위를 결정하는 규칙이다**

---

<h2> 호이스팅(Hoisting) </h2>

스코프 안에서 변수를 선언하였을 때 발생하는 호이스팅(Hoisting)이라는 동작에 대해 알아보자. **호이스팅은 선언문이 스코프 내의 가장 최상단으로 끌어 올려지는것을 의미한다.**

~~~
console.log(a); // undefined
var a = 1;
~~~

선언하기 전에 접근 하였으니 RefrenceError 가 발생할 것 같지만 예상과 달리 정상적으로 실행되어 undefined가 출력된다. 선언문 var a; 가 전역 스코프의 최상단으로 끌어올려지기 때문에 선언되기 이전에 참조가 가능하다. 호이스팅을 변수 생성 과정과 함께 살펴보자.

Js의 변수는 세 가지 단계로 나누어 생성된다.

1. 선언 : 스코프에 변수를 선언한다.
2. 초기화 : 변수의 값을 undefined로 초기화 하며, **실제로 변수에 접근이 가능하다**
3. 할당 : 할당문을 만나면 변수에 실제 값을 할당한다.

<h3> 스코프별로 동작하는 호이스팅 </h3>

호이스팅은 스코프별로 동작한다. 전역 스코프가 아닌 함수 내에 선언된 변수는 함수 스코프 안에서 호이스팅이 발생함

~~~
function foo() {
  console.log(a);
  var a = 1;
}
위 코드는 밑과 같이 처리된다.
function foo() {
  var a;
  console.log(a);
  a = 1;
}
~~~

<h4> let과 const </h4>

let과 const 키워드는 var와 다르게 선언과 초기화 단계가 분리되어 실행이 된다. 선언 단계는 스코프의 최상단으로 끌어올려져 실행되지만, 초기화 단계는 선언문을 만나면 실행이 된다. 그리고 초기화 단계 이전에 변수에 접근하려고 하면 참조에러가 발생한다. 

선언 단계가 실행되는 스코프의 최상단부터 초기화 단계를 실행하는 선언문이 나오기전까지는 변수에 접근이 불가함. 이 구간을 Temporal Dead Zone(TDZ)라 부른다.

**선언 단계는 스코프의 최상단으로 끌어올려져 실행이 된다.**
~~~
let ax = 3;
function foo2() {
  console.log(ax); // Uncaught ReferenceError: Cannot access 'ax' before initialization
  let ax = 1;
}
foo2()
~~~

함수 내에서 선언된 ax가 호이스팅되어 함수 최상단에 있으므로, error 발생 스코프 체인에 가장 안쪽 스코프인 지역변수 부터 검색을 진행하기 때문

<h3> 함수 선언문의 호이스팅 </h3> 

함수 선언문도 호이스팅이 발생하나, 선언, 초기화, 할당 세 가지 단계가 모두 동시에 스코프 최상단에서 이루어진다. 따라서 어느 위치에서든 함수를 호출 가능하다

함수를 변수에 할당하는 함수 표현식은 변수의 호이스팅 규칙에 따라 동작함.

---

<h2> 클로저(closure) </h2>

클로저는 함수의 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프를 벗어난 외부 스코프에서 실행될 때에도 자신의 렉시컬 스코프에 접근할 수 있게 해주는 것이다.

코드로 살펴보자 !

~~~
function foo() {
  var a = 1;
  function bar() {
    console.log(a); // 1
  }
  return bar;
}

const baz = foo();
baz(); // 1
~~~

위 코드는 다음단계로 실행이 된다.

1. bar() 함수는 렉시컬 스코프 체인을 통해 foo() 함수의 스코프를 기억함
2. bar() 함수를 전역 변수 baz에 할당함
3. baz를 사용하여 bar()를 호출함
4. baz() 함수는 자신의 스코프에서 a를 찾음
5. 찾을 수 없으므로 스코프 체인을 통해 foo() 스코프에서 찾음
6. foo() 함수 스코프에서 변수 a를 찾아 1을 출력한다

중요한 점은 bar() 함수가 자신과 상관없는 스코프에서 실행이 된다는 점이고 렉시컬 스코프 체인을 통해 변수를 찾는다는 것이다. 이것이 클로저 !

**즉 클로저를 사용하면 외부에서도 얼마든지 원래의 렉시컬 스코프에 접근이 가능하다**

<h3> 모듈 패턴 </h3>

클로저를 활용하면 모듈을 정의하여 원하는 프로퍼티나 메서드를 캡슐화가 가능하다

~~~
function myModule() {
  let count = 0;

  function increment() {
    count +=1;
  }
  function decrement() {
    count -=1;
  }
  function getCount() {
    return count;
  }

  return {
    increment,
    decrement,
    getCount
  }
}
~~~


myModule() 함수가 반환하는 객체는 참조만 가지며 내부 변수에 접근은 불가하다. 변수는 캡슐화 되어 외부 접근이 불가하며, 접근하고 싶다면 클로저 함수를 통해서만 접근이 가능하다. 이것이 클로저를 활용한 모듈 패턴이다 !

ES2015에서 모듈 명세가 등장하여 현재는 클로저로 구현하는 경우는 거의 없지만 이 원리는 알아두면 좋다

<h4> 즉시 실행 함수 표현식 </h4>

즉시 실행 함수 표현식(IIFE, Immediately Invoked function Expression)은 정의되자마자 실행되는 함수이며, 익명함수를 응용한 패턴이다. 즉시 실행 함수는 익명 함수를 괄호(())로 둘러싼 형태로 정의한다.

~~~
(function (lang) {
  //...
})('js');
~~~

함수를 괄호로 둘러싸고 인자를 주어 바로 실행하게 하였다 

~~~
const cleanModule = (function () {
  let count = 0;

  function increment() {
    count +=1;
  }
  function decrement() {
    count -=1;
  }
  function getCount() {
    return count;
  }

  return {
    increment,
    decrement,
    getCount
  }
})();

~~~

즉시 실행 함수를 모듈 패턴과 함께 사용하면 전역스코프를 오염시키지 않고 모듈 객체를 만들 수가 있다.

<h2> 모듈 </h2>

모듈은 외부로 공개한 API를 통해 상태를 변경하고 내부 구현에 대한 캡슐화의 역할을 한다 각각의 모듈은 애플리케이션을 구성하는 단위가 되며, 모듈 단위로 재사용하여 유지보수성을 높일 수 있다

ES2015에서 정식으로 모듈 문법이 등장함. ES모듈은 각 파일을 독립적인 스코프로 처리한다. 내보내기를 한 식별자가 아니라면 해당 모듈 내에서만 접근이 가능하다. 모듈은 다른 모듈에 정의된 특정 변수나 함수를 불러올 수 있고, 반대로 자신의 모듈 안에 정의된 식별자를 내보낼 수 있다

<h3>export, import </h3>

모듈 안에 선언한 식별자를 다른 모듈에 접근할수 있도록 하고 싶다면 export 키워드를 사용하여 내보내기를 하면 된다. 반드시 모듈의 최상위 위치(top-level)에 존재해야 한다.

함수 내부에서의 export 키워드는 에러 !

export 키워드를 사용하여 개별 식별자를 내보내는 것을 named exports 라고 부른다.

가져올 때는 최상단에 import 키워드와 중괄호로 감싸 가져올 수 있다.
`import {a,foo} from './a.js';`

모듈이 내보낸 식별자들을 하나의 이름으로 가져올 때는 as all을 사용하면 된다.
`import * as all from './a/js';`

<h3> default export </h3>

모듈에서 하나만 정의가 가능하다. `export default foo;`

default export로 내보낸 모듈을 다른 모듈에서 사용하는 경우, 중괄호({}) 없이 임의의 이름으로 가져와 사용한다


<h3> script type="module" </h3>

정의한 모듈을 브라우저 환경에서 사용하기 위해서는 script 태그에 type = "module" 속성을 설정하여 모듈임을 명시가 가능하다. 이렇게 정의된 파일은 모듈로 인식되어 전역 스코프를 공유하는 것이 아니라 모듈 스코프로 동작한다





















