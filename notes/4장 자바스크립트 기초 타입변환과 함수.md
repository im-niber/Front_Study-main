# 2021_12_22

드디어 기말고사 끝....

<h2>타입 변환</h2>

js에서의 타입변환에는 **명시적 강제 변환, 암시적 강제 변환** 이 두가지가 존재한다. 둘의 차이는 명확하다. 사실 이 두가지를 보는 기준은 사람마다 다를 수 있다. 타입 변환에 익숙한 사람은 전부 명시적 강제 변환으로 볼 수 있기 때문이다.

<h3> 명시적 강제 변환 </h3>

<h4> 문자열로 변환 </h4>

문자열로 변환하는 가장 간단한 방법은 String() 함수를 호출 하는 것이다. new 키워드를 붙이지 않고 String() 함수를 호출하면 랩퍼 객체를 생성하는 것이 아니라 타입 변환 함수로 동작한다.

~~~
console.log(String(3)); // '3'
console.log(String(false)); // 'false'
console.log(String(null)); // 'null'
~~~

타입별로 문자열 변환 방법이 정해져있고 ECMAScript에서는 이를 ToString 추상 연산이라고 명시한다.
심볼 타입은 변환되지 않는다 따로 SymbolDescriptiveString 연산을 수행해야함.

또 다른 문자열 변환 방법에는 toString() 메서드를 사용 하는 것이다.

차이점으로는 null과 undefined에서 TypeError 가 일어난다는 점이다. 당연히도 두 타입은 값이 비어있음, 할당되지 않은 상태를 뜻하므로 메서드를 호출하는건 논리적으로 말이 안된다.

---

<h4> 숫자로 변환 </h4>

숫자로의 변환은 `Number()` 함수를 이용하면 된다. Symbol, BigInt 타입을 제외한 데이터는 ECMAScript의 ToNumber 추상 연산 명세를 기준으로 변환 된다.

parseInt() 함수는 문자열만 대상으로 변환 시킨다. 이 함수의 두번째 인자는 기수를 의미하고 10 이라면 10진수로 표현하겠다는 의미이다.

Number() 와 다른 점은 parseInt는 대상이 변환이 불가능한 문자가 나타날 때까지 최대한 숫자로 변환시킨다.
Number()는 바로 NaN 반환을 하는 편

---

<h4> 불리언으로 변환 </h4>

object,Symbol 은 true이고 나머지는 false로 반환한다. 물론 값이 있거나 0이아니라면 true ! `Boolean()` 함수로 변환 시킨다. 다른 방법으로는 !!a 처럼 느낌표 연산자를 두 번 쓰는 방법이 존재함

---

<h3> 객체의 원시 타입 변환 </h3>

객체의 원시 타입변환은 문자열과 숫자 두 가지로 나눌 수 있고, 이 과정에서 `valueOf(), toString()` 메서드가 중요한 역할을 한다.

<h4> 문자열로 변환 </h4>

객체가 문자열로 변환되는 과정은 다음과 같다.
 1. 객체에 정의된 toString() 메서드를 호출함. 별도로 정의한 toString() 메서드가 없다면 기본적으로 Object.prototype.toString() 메서드를 실행함 이 메서드의 결과값은 `[Object object]` 를 반환한다.
 2. 1단계의 결과가 원시 타입이라면 문자열로 변환하여 반환하고 else 이면 valueOf() 메서드를 호출한다.
 3. valueOf() 메서드의 결과 값이 원시 타입이라면 문자열로 변환하여 반환하고 else이면 TypeError 반환

---

<h4> 숫자로 변환 </h4>

객체가 숫자로 변환되는 과정은 다음과 같다.
1. 객체에 정의된 valueOf() 메서드 호출함.
2. 1단계의 결과 값이 원시타입이라면 그 결과값을 숫자로 변환하여 반환한다. 그렇지 않다면 toString() 메서드를 호출한다.
3. toString() 메서드 결과 값이 원시 타입이라면 그 값을 숫자로 변환하여 반환함. else TypeError.

객체의 valueOf()와 toString() 메서드를 직접 정의하면 결과가 달라지므로 주의해야한다. 그리고 배열, Date, 정규식과 같은 특수 객체들은 자체적으로 메서드를 가지고 있다. 예를 들어 배열을 문자열로 변경하면 배열의 원소를 콤마(,)로 구분하여 문자열로 병합한다.

~~~
console.log([1,2]) // '1,2'
~~~

---

<h3> 암시적 강제 변환 </h3>

암시적 강제 변환은 타입이 아닌 연산자를 기준으로 살펴보겠습니다.

<h4> 덧셈 연산자 </h4>

덧셈 연산자의 특징은 다음과 같습니다.
- 피연산자중 하나가 문자열이라면 나머지 타입도 문자열로 변환하여 병합한다.
- 피연산자중 하나가 객체이며 문자열로 변환 가능한 경우 문자열로 변환하여 연산한다. 객체의 문자열 변환 과정은 문자열로 변환에서 설명한 과정과 동일.
- 피연산자가 모두 문자열과 객체가 아닌 경우 숫자로 변환하여 연산한다. 만약 결과의 타입이 각각 다르다면 TypeError 반환

~~~
console.log(1 + ''); // '1'
console.log(1 + {}); // '1[Object object]'
console.log(1+true); // 2
~~~

<h4> 동등 연산자 </h4>

동등 연산자의 가장 큰 특징은 암시적 강제 변환을 허용한다는 점이다. 특징을 살펴보겠습니다.
- 피연산자중 하나는 문자열, 하나는 숫자인 경우 문자열을 숫자로 변환하여 비교함.
- 피연산자중 하나는 문자열, 하나는 BigInt인 경우 문자열을 BigInt로 변환하여 비교
- 피연산자중 하나는 null, 다른 하나는 undefined인 경우 동등하게 판단
- 피연산자중 하나가 불리언일 경우, 불리언을 숫자로 변환하여 동등함을 비교
- 피연산자중 하나는 객체, 다른 하나가 문자열, 숫자, BigInt, 심볼 중 하나일 경우 객체를 원시 타입으로 변환하여 비교
- 피연산자중 하나는 숫자, 다른 하나는 BigInt인 경우 내부 숫자 비교 알고리즘을 통해 비교

<h4> 비교 연산자 </h4>

비교연산자는 크게 문자열 데이터의 비교, 그 이외의 경우 두가지로 나뉘어져 있다

>문자열 비교는 각 알파벳 순서로 비교한다. 따라서 앞글자가 중요.

문자열 외의 비교는 다음 특징을 가짐.
 - 피연산자중 하나는 문자열, 하나는 BigInt인 경우 문자열을 BigInt로 변환하여 비교
 - 피연산자를 모두 숫자로 변환하여 비교, 만약 피연산자중 하나는 숫자, 다른 하나는 BigInt인 경우 내부 숫자 비교 알고리즘에 의해 비교 수행

<h4> 비교 연산과 타입 변환 </h4>

비교 연산은 동등 연산과 달리 엄격한 비교 연산자 같은 표현식은 존재하지 않는다. **즉 다른 타입간의 비교에서 암시적 강제 변환을 막을 수 없다** 

---

<h4> 조건 표현식과 논리 연산자 </h4>

조건 표현식에서 암시적 강제 변환은 흔히 사용된다. **모든 값은 불리언으로 변환되어 조건 표현식에서 평가된다**

**논리연산자(&&,||)**

js에서의 논리 연산자는 단락 평가 방식을 따른다. js의 특이한 점은 **논리 연산자의 결과 값이 불리언 타입이 아닐 수 있다** 라는 점이다.

- && 논리 연산자는 처음 피연산자의 값이 true 이면 두번째 피연산자의 값을 반환하고 false 이면 처음 피연산자의 값을 반환한다.
- || 논리 연산자는 처음 피연산자의 값이 true 이면 처음 값을 반환하고, false이면 두 번째 피연산자의 값을 반환한다.

~~~
const a = null;
const b = 'js';
const c = 1;

console.log(a && b) // null
console.log(b || c) // 'js'
~~~

이를 활용하여 조건에 따라 함수를 실행할 때, 디폴트 값을 설정할 때 유용하게 사용된다.

~~~
function setDefault(a) {
  return a || 'default string';
}
~~~

추가로 ES2020에서 등장한 null 병합(nullish coalescing) 연산자가 존재함

~~~
const a = null; // '' 는 값이 있는 것

//a가 null, undefined인 경우에만 'default' 문자열이 b의 값으로 할당 됨(falsy 값 x)
const b = a ?? 'default';

~~~

---

<h2> 함수 </h2>

js 에서 함수는 가장 중요한 개념 중 하나이며 js 함수만의 독특한 특징들이 있다. 따라서 제대로 이해해야 한다

<h3> 함수란 무엇인가? </h3>

함수는 객체의 특별한 형태이며 문(statement)로 구성된 몸체를 가진 하나의 실행 단위이다.
~~~
function doSomething() {
  console.log('hello js');
}
~~~

또한 js의 함수는 **일급 함수(first-class function)**로서 다른 함수의 매개변수 값으로도 사용이 가능하다
~~~
function finishSomething(callback){
  callback();
  console.log('finish');
}
finishSomething(doSomething);
~~~

# 2021_12_23


위 처럼 **다른 함수의 인자로 넘어가는 함수를 콜백 함수** 라고 부르며, 이 패턴은 js에서 자주 사용되는 패턴이다. 대표적인 예로 DOM에 이벤트를 추가하는 addEventListener() 함수가 있다

~~~
button.addEventListener('click', callback);
~~~

> 일급 함수는 다음을 만족해야한다.
 >- 변수에 함수를 할당할 수 있어야한다.
 >- 함수를 인자로 전달할 수 있어야한다.
 >- 함수를 반환 값으로 사용할 수 있어야한다.

<h3> 함수의 정의 방법 </h3>

js의 함수는 function 키워드로 정의되며 다음과 같은 구성요소를 가지고 있다.

 - 함수의 이름(식별자) 
 - 함수의 매개변수 : 매개변수는 괄호 안에서 쉼표로 분리하며, 함수의 몸체에서 지역 변수처럼 사용된다.
 - 함수의 몸체 : 중괄호({}) 안에 정의하며, 함수가 호출될 때마다 실행되는 문의 집합이다.

~~~
function doSomething(a) {
  console.log(a);
}
~~~

위에서 `doSomething` 은 함수의 이름 , `a` 는  함수의 매개변수이고, `console.log(a);` 는 함수의 몸체이다. 함수를 생성하는 방법은 세가지가 존재한다. 여기에서는 함수 선언문, 함수 표현식만을 다룰 것이며, function 생성자 함수는 다루지 않을 것이다. function 생성자 함수는 보안 및 성능 문제가 있어 권장되지 x

<h4> 함수 선언문 </h4>

힘수의 이름, 매개변수, 몸체로 구성되며, 함수의 이름이 반드시 정의되야한다. 함수 선언문이 실행되면 함수의 이름과 동일한 변수를 정의하여 함수 객체를 변수에 할당한다.

함수 선언문에는 독특한 특징이 있다. js에서 흔히 말하는 **호이스팅(hoistiong)**으로 인해 함수의 선언된 위치에서 코드의 최상단으로 끌어올려진다. 따라서 선언된 위치보다 위에서도 호출이 가능하다

<h4> 함수 표현식 </h4>

함수 표현식은 함수 선언문과 달리 **함수의 이름이 선택 사항**이며, 변수에 함수를 직접할당한다.
~~~
const multiply = function (a,b) {
  return a*b;
}
~~~

위는 변수를 선언하여 함수 객체를 할당하였다. 이렇게 이름이 없는 함수를 익명 함수(anonymous function) 표현식 이라고 부른다. 

이름이 있는 함수 표현식은 기명 함수 표현식이라고 한다. 기명 함수 표현식의 이름은 함수의 몸체에서만 사용이 가능하다
~~~
const multiply = function doSomething(a,b){
  return a * b
}

console.log(multiply(2,3)) // 6
console.log(doSomething(2,3)) // ReferenceError
~~~

그러면 기명 함수 표현식은 어떤 경우에 사용할까요 ? 주로 함수 표현식을 재귀적으로 호출할 때 사용한다
또한 함수 표현식은 함수 선언문과 달리 호이스팅이 되지 않기 때문에 변수에 함수를 할당하기 전에 호출할 수 없습니다.

<h4> 함수의 호출 </h4>

함수 선언문과 또는 함수 표현식으로 함수를 정의하였다면 함수를 호출하여 실행할 수 있다. 함수 호출은 표현식이기 대문에 값으로 평가되며, 함수 몸체 안에 return 문을 사용하여 결과 값을 반환할 수 있다. 만약 return 문을 명시적으로 호출하지 않는다면 함수 호출의 결과 값은 undefined가 된다.

# 2021_12_24

<h4> 매개 변수 </h4>

함수를 정의할 때 매개변수(parameter)를 명시하여 정보들을 전달이 가능하다.

~~~
//name 이라는 매개변수를 명시하여 필요한 정보를 전달 받을 수 있다.
function greeting(name) {
  return 'Hello ${name}' ;
}
~~~

js는 느슨한 타입을 가진 언어이기 때문에 매개변수 역시 타입을 명시하지 않는다. 또한 함수 호출 시 전달하는 인자 값도 검사하지 않으며, 심지어 인자의 개수도 검사하지 않는다. 호출 시 본래 정의된 매개변수보다 적은 수로 인자를 전달한다면 나머지 매개변수 값은 undefined 값으로 설정된다. 반대로 정의된 매개변수보다 많은 인자를 전달한다면 나머지 인자 값은 무시됩니다.

> 인자와 매개변수는 동일한 의미 같지만 구분되어야 한다. 인자는 함수 호출 시 전달되는 값을 의미, 매개변수는 함수에서 전달된 인자를 받아들이는 변수를 의미 영문으로는 인자는 argument, 매개변수 parameter 로 사용함.

~~~
function greeting(name) {
  return 'Hello ${name}';
}

console.log(greeting()); //'Hello undefined'
console.log(greeting('Lee','Han')); // 'Hello Lee'
~~~

<h4> 해체 할당과 매개변수 기본값 </h4>

함수의 매개변수는 ES2015의 해체 할당과 매개변수 기본값을 사용하여 좀 더 편리하게 사용할 수 있다. 매개변수 해체 할당은 객체와 배열 모두 가능하며 프로퍼티가 없는 변수는 undefined를 할당 받음

~~~
function getuserinfo({name, age, country}){
  return 'name : ${name}, age : ${age}, country : ${country}';
}
const userinfo = {name : 'Lee' , age : 20};
console.log(getuserinfo(userinfo)); // 'name : Lee, age : 20, country : undefined' 
~~~

매개변수에 해당하는 인자를 넘기지 않으면 매개변수 값은 undefined로 설정이 됩니다.
만약 undefined가 아닌 기본 값을 할당하고 싶은 경우 매개변수 기본값을 사용하여 지정이 가능하다.

~~~
function greeting(name = "lee") {
  return "hi ${name}";
}
console.log(greeting()) 
~~~

<h4> arguments </h4>

화살표 함수를 제외한 모든 함수는 arguments 객체를 사용 가능 이 객체를 사용하여 함수에 실제 전달된 인자들을 참조 가능하다. 또한 유사 배열 객체이기 때문에 idx로 프로퍼티에 접근이 가능 하며 length 프로퍼티를 가지고 있다.

arguments 객체는 ES2015에 등장한 **나머지 매개변수**로 대체 가능핟. 나머지 매개변수는 유사 배열 객체가 아닌 진짜 배열이기 때문에 인자들을 배열로 다루고 싶은 경우 유용하게 사용 가능 

~~~
function sum(...args) {
  //args 는 배열이기 때문에 배열 내장 메서드인 forEach() 사용 가능
  args.forEach(function (arg)){
    //...
  }
}
~~~

나머지 매개변수는 일반 매개변수와도 함께 사용 가능하다. 하지만 이 경우 마지막 매개변수만 나머지 매개변수가 될 수 있습니다.

`function sum(type, ...args)`

<h3> 화살표 함수 </h3>

ES2015에 등장한 문법으로 기존의 함수 표현식에 비해 간결하게 함수를 작성 가능함. 화살표 함수는 항상 익명함수 이며, 다음 특징이 있다.
 - function 키워드 생략
 - 매개변수가 하나인 경우 괄호 생략 가능
 - 몸체에서 문이 하나인 경우 중괄호나({}) return 키워드 생략 가능

~~~
const greeting1 = () => {return 'hello';};
const greeting2 = name => {return 'hello ${name}';};
const greeting3 = name => 'hello ${name}';
~~~

이 간결함은 map()과 filter() 와 같이 사용하면 효율적이다.

<h4> 화살표 함수의 특징 </h4>

또 다른 점 두가지가 존재 한다. 화살표 함수는 arguments 객체와 this를 바인딩 하지 않기 때문에 기존 함수와 다르게 동작함.  

화살표 함수에서는 나머지 매개변수를 사용하여 arguments 객체를 대체 가능함

> 일반적으로 변수와 변수에 관련된 프로퍼티를 연관시키고 값을 설정하는 것을 바인딩 이라고 한다. js에서는 함수 호출 시 값이 결정되는 arguments 객체나 this 바인딩된다는 표현을 자주 사용한다.

---

<h3> this </h3>

Js의 함수에서는 this 특별한 키워드를 사용 할 수 있다. this는 읽기 전용 값으로 런타임시 설정할 수 없으며 **함수를 호출한 방법에 의해 값이 달라진다.**

<h4> 일반 함수 </h4>

일반 함수를 설명하기 앞어 먼저 전역 실행 컨텍스트에서의 this 바인딩을 살펴보겠다. 전역 실행 컨텍스트에서의 this는 항상 **전역 객체**를 참조한다. 전역 실행 컨텍스트는 js 엔진이 코드를 실행할 때 처음으로 생성되는 컨텍스트이다. js 코드가 실행되는 최상위 환경이라 할 수 있다.

> 전역 객체는 js를 실행하는 환경마다 다르다. 브라우저 환경에서 js를 실행한다면 window 객체가 전역 객체가 전역객체이며, Node.js 환경이면 global 객체가 전역 객체가 된다.














