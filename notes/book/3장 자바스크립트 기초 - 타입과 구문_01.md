## 2021_12_09

## 3장 자바스크립트 기초

<h3>변수 선언</h3>

자바스크립트는 정적 타입 언어와는 다르게 **느슨한 타입(loose typing)** 을 가진 언어이기 때문에 데이터 타입을 명시하지 않고 변수를 선언할 수 있다.

`느슨한 타입이라고 타입이 존재하지 않는 것은 아니다. 내부적으로는 데이터의 종류에 따른 변수의 타입을 가진다.`

---

<h4> var </h4>

var 키워드로 변수를 선언하는 것은 ES2015(ES6)에서 let 과 const가 등장하기 전까지 유일한 방법이었습니다. var로 선언된 변수는 기존 값을 덮어쓰며, 함수 스코프를 기준으로 동작한다.

~~~
var a = 1;

if (isSomething())  {
  var a = 2;
}
console.log(a); // 2
~~~

var로 변수를 선언한 경우 스코프 내에 이미 동일한 식별자를 가진 변수가 존재한다면 해당 변수에 값을 재할당한다. 값을 덮어쓰는 경우가 있어 다른 코드에 영향을 주거나 버그가 발생 시 찾기가 힘들다.

블록 또는 함수 스코프내에서 선언한 것이 아니라면 변수는 전역 스코프를 가짐. 이를 전역 변수라고 한다. 

변수가 함수 스코프를 가진다는 것은 **변수를 선언한 함수 몸체 안에서만 해당 변수에 접근이 가능하다는 의미** 이다.


<h4>let과 const</h4>

let과 const는 ES2015에서 등장한 변수 선언 키워드이다. 재선언을 허용하지 않으며, 함수 스코프가 아닌 블록 스코프를 가진다.

const는 let과 달리 값 변경이 아예 불가능하다는 차이가 있다.

자바스크립트 진영에서는 var보다는 let과 const를 사용하라고 권장하고 있다.

---
<h3>객체와 타입</h3>

자바스크립트의 값은 원시 타입(Primitive Type)과 객체(참조형)로 나뉜다. 원시 타입은 다음과 같이 7가지가 있다.

- number, string, boolean, null, undefined, Symbol, BigInt(ES2020에서 추가)

원시 타입은 하나의 값만 가지며, 불변 데이터이기 때문에 연산을 해도 기존 데이터는 변하지가 않는다. 

원시 타입을 제외한 나머지는 모두 객체이다. 배열, 함수, 정규식 등 전부다 객체에서 파생된 특수한 타입이다.

---

<h4> number </h4>

JS의 숫자 타입은 저수, 실수 구분 없이 숫자 타입 한 가지만 존재한다. 숫자 타입은 모든 데이터를 64비트의 부동 소수점 형태로 저장하기 때문에 진정한 정수 데이터는 존재하지 않음.

<h4> NaN </h4>

JS에는 NaN이라는 특별한 속성이 존재함. Not A Number라는 값이며 읽기 전용 속성이다. 숫자로 변환할 수 없는 값을 숫자로 변환하려고 하거나 산술 연산의 결과가 숫자가 아니면 NaN값이 반환 된다.

NaN은 자기 자신과도 동등하지 않은 결과를 반환하기 때문에 Number.isNaN() 함수를 사용해서 판별하기 바란다.

<h4> 소수점 연산 </h4>

JS에서 널리 알려진 소수점 연산의 문제점이 있다.
`0.1 + 0.2 === 0.3 // false`
정확한 값이 아닌 근삿값 연산이기 때문에 답은 false이다. 이러한 문제는 Number.EPSILON을 사용해 해결이 가능하다.

정밀한 소수점 연산 또는 굉장히 큰 단위의 연산이 필요하지 않다면 JS의 연산은 믿고 사용해도 된다.

---

<h4> string </h4>

string은 텍스트를 표현하는 타입이다. js의 문자열은 리터럴 형태로 주로 사용하며, 홑따옴표, 쌍따옴표, 백틱(``)을 이용해 표현함.

js의 문자열은 16비트의 유니코드 문자 집합을 연속적으로 나열한 것이다.

<h4> 이스케이프 </h4>

문자열을 사용하다 보면 홑따옴표 또는 쌍따옴표를 텍스트 데이터로 표현해야 할 때가 있습니다. 이럴때는 역슬래시(\) 문자로 이스케이프 처리해 사용한다.

- \n : 줄바꿈 문자, \r : 캐리지 리턴, \t : 수평 탭, \v : 수직 탭, \f : 폼 피드

<h4> 템플릿 리터럴 </h4>

ES2015의 템플릿 리터럴이 등장하면서, 문자열 내의 변수나 상수를 간결하게 표현할 수 있게 되었다. 달러 기호와 중괄호(${})로 표현식을 감싸 문자열 안에 그값을 삽입할 수 있다.

~~~
const name = 'javascript';
cost sentence = 'I love the &{name}';
~~~

---

<h4> boolean </h4>

불리언 타입은 true, false 두 가지 값만을 가지며 참과 거짓을 표현할 때 사용한다. 

<h4> null과 undefined </h4>

null은 값이 없음을 나타내는 특별한 타입이다. 대다수 언어에서 값이 없음을 나타내고 싶을 때 null 타입을 사용한다. 하지만 js에는 값이 없음을 나타내는 또 다른 타입인 undefined가 있다. 값이 할당되지 않는 변수나 반환 값이 없는 함수의 결과값은 자동으로 undefined가 할당된다. 

여기서 팁으로 알려주는 것은 의도적으로 값이 없음을 나타내고 싶을 때는 null을 사용하고, 값이 할당되지 않음을 나타내고 싶을 때는 undefined를 할당한다. 

---

<h4> Symbol </h4>

심볼은 Es2015에서 도입된 원시 타입이다. 데이터의 유일함을 나타낼 때 사용하며, 생성된 심볼은 다른 어떤 심볼과도 일치하지 않는다. 

<h4> 전역 심볼 </h4>

전역 심볼을 생성해 매번 새로운 심볼을 생성하지 않고 기본 심볼을 검색해 사용하기도 한다. Symbol.for() 메서드를 사용하면 전역 심볼을 생성하며, 사용할 때는 다른 라이브러리와 충돌을 피하도록 prefix를 사용해 구분하는 것이 좋다.

<h4> 심볼의 활용 </h4>

심볼은 객체나 클래스에서 유일한 프로퍼티를 만들 때 사용한다. 심볼을 사용해 프로퍼티를 만들면 유일함이 보장되어 프로퍼티 추가 시 충돌이 날 염려가 없다. 또한 외부에서 직접 해당 프로퍼티에 접근 할 수가 없어 의도치 않은 프로퍼티 변경을 막을 수 있다.

~~~
const user = {
  name : 'javascript'
};
const id = Symbol('id');
user[id] = 'firstId';
// 심볼은 유일한 값이라 외부에서 직접 프로퍼티에 접근 x
console.log(user[Symbol('id')]); // undefined
~~~

---

<h3>객체</h3>

js에서 원시 타입이 아닌 모든 값은 객체이다. 객체는 **이름(키):값** 형태로 여러 값을 포함하는 컨테이너이며, 내부의 값은 얼마든지 변경이 가능하다. 이름에 해당하는 프로퍼티 명은 숫자와 문자열, 심볼만 가능하며 값에 해당하는 프로퍼티는 어떤 표현식이든 올 수가 있다.

<h4> 객체의 생성 </h4> 

객체를 생성하는 방법은 세 가지이다. Object() 생성자 함수를 사용하는 방법, 객체 리터럴({})을 사용하는 방법, 직접 정의한 생성자 함수를 사용하는 방법이다.


Object()는 객체를 생성하도록 js에 내장된 생성자 함수이다. 하지만 뒤에 설명할 객체 리터럴을 사용해 생성하는 것이 훨씬 간결하기 때문에 거의 사용되지 않는 편이다.

<h4> 객체 리터럴 </h4>

중괄호를 사용해 객체를 생성하는 강력한 문법이다. 이름 : 값 형태로 프로퍼티 이름과 값을 중괄호 안에 정의해 객체를 생성한다

~~~
const obj = {
  name : 'name',
  id : 'id'
};
~~~

객체리터럴은 간단한 문법으로 객체 생성과 동시에 프로퍼티까지 추가가 가능해서 가장 많이 사용되는 방법이다.

<h4> 생성자 함수 </h4>

js에서 생성자 함수는 형식이 정해져 있지 않습니다. 함수를 선언해 new 키워드를 사용해 호출하면 해당 함수는 생성자 함수로 동작한다.

하지만 모든 함수를 생성자 함수로 사용하지 않기때문에 일반함수와 생성자 함수를 구분하기 위해 **생성자 함수 이름의 첫 글자를 대문자로 표기** 하는 것을 권장함.

~~~
function Vehicle(type){
  this.type = type;
}
const car = new Vehicle('Car');  // {type: 'Car'}
~~~

<h4> 객체의 프로퍼티 읽기 </h4>

객체의 프로퍼티는 점 표기법 또는 대괄호 표기법으로 접근한다. 

~~~
obj.name;
obj.age;
obj.child.name;

obj['name'];
obj['age'];
~~~

대부분은 점 표기법을 많이 사용하지만 대괄호 표기법을 사용해야만 접근 가능한 경우가 있다. 변수를 사용해 프로퍼티에 접근하거나 접근하려는 프로퍼티 명에 연산자가 포함된 경우에는 반드시 대괄호 표기법을 사용해야한다.

~~~
const prop = 'name';
obj[prop];
obj[last-name];
~~~

두 표기법 모두 객체에 존재하지 않는 프로퍼티에 접근할 경우 undefined를 반환함.

<h4> 동적 프로퍼티 생성과 갱신 </h4>

js의 객체는 생성된 후에도 동적으로 프로퍼티를 생성하거나 갱신이 가능하다. 프로퍼티가 존재한다면 갱신하고 존재하지 않는다면 추가한다.

<h4> getter와 setter </h4>

어떤 프로퍼티에 접근할 때마다 동적인 계산이 필요하거나 프로퍼티 값이 변경될 때마다 처리 코드가 필요한 경우에 getter와 setter 접근자 프로퍼티를 사용해 일반 프로퍼티처럼 사용이 가능하다. 접근자 프로퍼티의 값에 접근하면 getter 메서드가 호출되며 변경하려고 하면 setter 메서드가 호출이 된다.

~~~
const obj = {
  myName : 'js',
  set name(name){
    if (name !== null){
      this.myName = name;
    }
  },
  get name() {
    return this.myName;
  } 
}
~~~

접근자 프로퍼티를 정의하는 가장 간단한 방법은 객체 리터럴 문법을 사용하는 것이다. get/set 문법을 사용해 정의하며, 프로퍼티의 값을 갱신할 때 유효성을 검증하거나, 조건에 따라 다른 값을 반환하는 작업을 할 때 사용한다.

<h4> Object.defineProperty()와 속성 </h4>

접근자 프로퍼티를 생성하는 또 다른 방법은 정적 메서드 Object.defineProperty()를 사용하는 것이다. 이 메서드는 객체에 직접 새로운 프로퍼티를 정의하거나 이미 존재하는 프로퍼티를 수정한 후 그 객체를 반환한다.

~~~
cosnt obj = {myName : 'js'};

Object.defineProperty(obj,'name',{
  set(name) {
    if (name !== null){
      this.myName = name;
    }
  },
  get() {
    return this.myName;
  }
});
~~~

이 메서드는 첫 번째 인자로 대상이 되는 객체, 두 번째 인자로 추가 또는 갱신하려는 프로퍼티명이나 심볼을 넘긴다. 그리고 마지막 인자로 프로퍼티 서술자를 정의한 객체를 넘긴다. getter와 setter를 포함해 여러 서술자들이 존재.

---

<h3> 배열 </h3>

배열은 객체의 특별한 형태로 순서가 있는 데이터의 집합이다. 인덱스는 0부터 시작하는 정수이다. 

<h4> 배열의 생성 </h4>

배열은 Array() 생성자 함수나 배열 리터럴([])을 사용해 생성한다.

객체와 마찬가지로 배열도 js에 내장된 생성자 함수 Array()가 있으며, 이를 사용해 배열을 생성할 수 있다.

~~~
cosnt arr = new Array(1,'2',true);

const arr2 = new Array(3);
console.log(arr2); // [empty,empty,empty]
~~~

Array()생성자 함수는 새로운 배열을 생성하고 인자로 받은 값들을 배열 원소로 채워 넣어 초기화 한다. 만약 생성자 함수의 인자가 1개이고 숫자 값이라면 해당 값을 배열의 length 프로퍼티에 할당해 새로운 배열을 생성함.

하지만 Array() 생성자 함수 역시 배열 리터럴 문법이 더 간단하여 잘 사용하지 않음.

<h4> 배열 리터럴 </h4>

배열 리터럴은 대괄호를 사용하낟. js에는 배열 안의 원소들의 타입이 달라도 되는데 이것을 비균질적 배열이라고 한다. 하지만 이런 배열 데이터는 일관성 있게 처리하기 힘들어 가급적 실제 배열 데이터는 통일된 타입의 데이터를 사용 하는 것이 좋다.

<h4> 원소 접근과 동적인 원소 생성 </h4>

배열 원소는 대괄호안에 인덱스 값을 넣어 접근한다. 만약 배열 길이보다 큰 인덱스값을 넣어 접근한다면 값이 할당되지 않아 undefined를 반환함.

배열도 객체이기 때문에 동적으로 배열 원소를 추가할 수 있다. 특히 js의 배열은 순차적으로 값을 넣지 않아도 된다. 이때 값을 추가한 인덱스의 위치에 따라 length 프로퍼티도 갱신된다. **배열의 length 프로퍼티는 항상 최대 인덱스보다 크기 때문이다**

<h4> 희소 배열 </h4>

배열의 중간 원소가 비어있는 배열을 뜻 한다. 희소 배열의 빈 원소는 forEach(), map(), filter()와 같은 배열의 내장 메서드에서 무시된다. 반면 find(), findIndex() 메서드는 빈 원소를 무시하지 않고 모두 탐색하기 때문에 일관적이지 않은 동작을 수행한다.
코드 가독성이나 데이터 구조 파악에도 좋지 않으니 특수한 경우를 제외하고는 사용을 지양해야한다.

# 2021_12_10

<h4>length 프로퍼티 </h4>

js 배열의 length 프로퍼티는 배열의 길이를 반환함. 항상 배열의 최대 인덱스보다 크다.

length 프로퍼티를 수정해 배열의 길이를 늘리거나 줄일 수도 있다. 이때 수정한 배열의 길이에 맞게 배열의 원소도 추가(빈 원소)되거나 삭제된다.

---

<h4> 배열 조작 </h4>

배열은 원소를 조작할 수 있는 내장 메서드를 가진다 배열의 원본 데이터를 직접 수정하는 메서드와 기존 배열 데이터를 기반으로 조작해 새로운 배열을 생성하는 두가지로 나뉨.

<h3> 원본 배열 데이터 수정 메서드 </h3>

- shift() : 배열의 첫 번째 원소를 삭제하고, 결괏값으로 삭제된 원소를 반환함.
- unshift() : 배열의 첫 번째 원소를 추가하고, 결괏값으로 배열의 새로운 길이를 반환
- push() : 배열의 마지막 인덱스에 하나 이상의 원소를 추가하고, 결괏값으로 배열의 새로운 길이를 반환
- pop() : 배열의 마지막 인덱스에 해당하는 원소를 삭제하고 그 값을 결과값으로 반환
- splice() : 배열의 원소를 추가하거나 교체 또는 삭제해 배열 데이터를 변경함 결과값으로 삭제된 데이터의 배열을 반환함.
- sort() : 배열의 원소를 인자로 넘긴 비교 함수를 사용해 정렬함. 비교 함수 생략시 각 원소의 유니코드 포인트 값에 따라 정렬된다. 단, 숫자도 문자로 변환하여 정렬한다는 것을 명심해야함

<h3> 새로운 배열 생성 메서드 </h3>

- concat() : 인자로 넘긴 배열 또는 값들을 기존 배열에 합쳐 새로운 배열을 생성해 반환
- slice() : 배열에서 특정 범위의 원소를 복사해 새로운 배열을 생성해 반환 얕은 복사임을 주의

배열을 복사하는 또 다른 방법은 펼침 연산자(Spread Operator)를 사용하는 것이다. 이것도 얕은 복사로 수행된다.

~~~
const arr = [1,2,3];
cost newArr = [...arr];
console.log(newArr); // [1,2,3]
~~~

- map() : 배열의 모든 원소를 인자로 받은 함수를 실행해 특정한 형식으로 변경. 변경한 원소들로 새로운 배열을 반환함.

~~~
const arr = [1,2,3];
const newArr = arr.map(x => x+1);

console.log(newArr) // [2,3,4]
~~~

- forEach() : 인자로 받은 함수를 배열의 모든 원소를 대상으로 실행.

~~~
const arr = [1,2,3];
const newArr = arr.forEach(x=> console.log(x));
~~~

- filter() : 인자로 받은 함수의 테스트를 통과하는 원소들로 새로운 배열을 생성해 반환

~~~
const arr = [1,2,3];
const newArr = arr.filter(x => x != 1);

console.log(newArr) // [2,3]
~~~

---

<h3> 유사 배열 객체 </h3>

js에서는 일반 객체를 배열처럼 사용할 수 있다. 이러한 객체를 **유사 배열 객체** 라고 한다. 유사 배열 객체는 length 프로퍼티로 양의 정수 값을 가진 객체여야만 한다.

~~~
const arr = {
  0 : 'hi',
  1: 'my' ,
  2: 'name',
  length : 3
};
~~~

유사 배열 객체의 대표 예는 js 함수의 arguments 객체이다. arguments 객체는 함수에 전달한 인자를 유사 배열 객체로 만든 데이터이다.

~~~
function foo(a,b,c){
  console.log(arguments[0],arguments[1],arguments[2]); // 'a', 'b', 'c'
  console.log(arguments.length) // 3
}
foo('a','b','c');
~~~

하지만 배열이 아닌 유사 배열 객체이기 때문에 배열의 내장 메서드를 사용할 수 없다. 사용 해야할 경우에는 call(), apply() 함수와 결합하여 사용함.

~~~
function foo(a,b,c){
  Array.prototype.forEach.call(arguments, (arg) => {
    console.log(arg);
  });
}
foo('a','b','c');
~~~

유사 배열 객체는 DOM을 다루다 보면 자주 접하는 데이터이니 제대로 이해하고 사용할 수 있어야 한다. 

---

<h3> 랩퍼(Wrapper) 객체 </h3>

랩퍼 객체를 살펴보기 전에 간단한 예제 코드를 살펴보자.

~~~
const str = 'javascript';
console.log(str.length); // 10
~~~

str 변수는 문자열 원시 타입인데도 객체처럼 length 프로퍼티에 접근한다. js는 문자열의 프로퍼티에 접근할 때 내부적으로 문자열 값을 가지고 임시 객체로 변환함. 그리고 접근이 종료되면 생성된 객체는 메모리에서 제거된다. 이런 과정을 js에서는 **박싱(boxing)** 이라 한다. 숫자와 불리언 타입 역시 프로퍼티에 접근시 동일한 과정을 실행

**박싱 과정에서 생성되는 임시 객체를 랩퍼객체** 라고 한다. 랩퍼 객체는 문자열, 숫자, 불리언 타입만 존재하며, 각각에 대응되는 네이티브 생성자로 String(), Number(), Boolean()이 존재함.

<h4> 언박싱(Unboxing) </h4>

박싱과 반대로 동작하는 언박싱에 대해 알아보자. 언박싱은 랩퍼 객체를 원시 타입으로 변환한다. 언박싱은 명시적으로 valueOf() 메서드를 호출해 수행할 수 있다.

하지만 언박싱은 valueOf() 메서드를 호출해 수행할 때보다는 값을 다른 타입으로 변경하는 타입 변환을 할 때 수행되는 경우가 많다.

---

<h3> 구문과 연산자 </h3>

프로그래밍 언어에서 구문(Syntax)은 애플리케이션 또는 프로그램을 만들기 위해 언어가 작동하는 규칙을 정의하며, 정형화된 문법에 따라 작성해야한다. 언어의 문법과 구성요소에 대해 명확하게 이해해야함.

<h4> 표현식(Expression) </h4>

js에서 표현식과 문의 차이를 이해하는 것은 매우 중요하다. 먼저 표현식은 값으로 평가되는 구문이다. 예를 들어 임의의 숫자나 문자열은 모두 표현식이다.
`값을 반환한다는 표현을 js에서는 보통 값을 평가한다고 표현함.`

~~~
'javascript'; // 문자열은 결괏값으로 js를 반환하는 표현식이다.
var a;
a = 1; // 할당하는 것도 표현식 .

var x = 1;
var y = 2;
x + y; // 다른 표현식과 결합해 다른 결과값을 얻기도 한다. 이러한 것을 복합 표현식이라고 한다.
~~~

---

<h3> 문(Statement) </h3>

js의 문은 일종의 지시를 내리는 것이다. A라는 값과 B라는 값을 더해라 처럼 지시를 내리는 것을 js에서는 문이라고 한다. 표현식이 값으로 평가되는 결과값을 가져온다면, 문은 표현식 또는 다른 문을 조합해 동작을 수행하는 지시를 내린다.

~~~
let a;
cost b = if(true) {a = '1'}; // error, 결과값을 가지지만 할당 x

~~~

문을 만드는 간단한 방법은 부수 효과(Side-Effect)가 있는 표현식을 실행하는 것이다. 부수효과가 있는 표현식은 독립적인 문으로 사용 가능하다. 앞서 본 할당 표현식이 대표적인 예이다. 변수에 다른 값을 할당해 변숫값을 변화시킨다. 즉 변숫값 변화라는 부수효과가 발생한다. 이렇게 **문으로도 사용할 수 있는 표현식을 표현문** 이라고 한다.

<h4> 표현문 </h4>

부수 효과가 있는 표현식으로 할당 표현식 또는 함수 호출과 같은 표현식이다.

~~~
function doSomething(){
  //...
}
doSomething(); // 함수 호출도 표현문 
~~~

- 선언문 : var a = 1; 같은 변수 또는 함수를 정의하는 문.
- 조건문 : 조건부에 해당하는 표현식의 값에 따라 문을 실행하거나 건너 뛴다.
- 반복문 : 조건표현식의 결과가 true라면 반복문 내의 코드를 실행한다. 이 과정을 조건 표현식의 결과가 false가 나오지 않는 한 계속 실행함.
- 점프문 : 특정 위치로 건너뛰어 문을 실행한다. break문, continue문, return 문 등이 있다.

---

<h3> 연산자(Operator) </h3>

표현식이 값으로 평가된다면 **연산자는 값을 만들어 내는 방법** 이다.

- 산술연산자 : js에서는 여러 산술연산자가 존재함. 대부분 비슷하므로 처음 본 산술 연산자만 설명하겠다. 
 - +단항 : 피연산자 값을 숫자로 변환, 결합 방향 우 -> 좌, 값을 숫자로 변환할 수 없는 문자열일 경우에 NaN을 반환한다. 

<h4> 논리 연산자 </h4>

논리 연산자 &&, ||, !는 보통 참과 거짓을 나타내는 불리언 값을 이용해 연산을 수행하며 결과값도 불리언이다. 하지만 js에서는 **불리언이 아닌 값도 논리 연산자의 피연산자가 될수 있다** 불리언이 아닌 값이 온다면 truthy값과 falsy 값이라는 개념을 사용해 피연산자를 평가함.

<h4> truthy 값과 falsy 값 </h4>

truthy 값은 참과 같은 값이다. 이 값들은 불리언 타입은 아니지만, 논리연산자와 함께 사용하면 참으로 평가한다. falsy는 반대이다.

falsy 값의 종류는 다음과 같다.
- false, ''(빈문자열), null, 0, undefined, NaN, 0n

이들 외에는 모두 truthy 값이다. 주로 착각하는 몇가지를 소개하겠다.

- 빈 배열, 빈 객체 : 배열이나 객체는 항상 참으로 평가함. 빈 배열을 거짓으로 평가하고 싶다면 length 프로퍼티를 사용하면 된다.
- 공백 또는 줄 바꿈 문자열 : 공백과 줄 바꿈을 표현하는 문자열 값이 있으므로 참
- 문자열 'false' : const a = 'false'를 보면 'false'라는 값이 있어 참이다.

추가로 NOT(!)연산자를 두번 쓰는 이중 부정 연산자가 존재한다. 주로 기존 값을 불리언 타입으로 변환 시킬 때 사용한다.

<h4> 단락평가(Short Circuit) </h4>

AND 연산자와 OR 연산자는 단락 평가라는 특징을 가짐. AND의 경우 앞의 결과가 거짓 이라면 뒤의 평가 결과와는 상관 없이 FALSE를 반환. 뒤의 평가식을 평가하지 않음. OR 연산의 경우 앞의 결과가 참이면 뒤의 평가 결과와 상관없이 TRUE를 반환. 마찬가지로 뒤는 평가 안함. 이러한 방식을 **단락 평가** 라고한다.

~~~
if(x<y){
  doSomething();
}

x<y && doSomething(); // 위의 if문과 똑같은 동작을 함.

~~~

<h4> 관계형 연산자 </h4>

부등호와 등호 같은 연산자들을 뜻함. js에서 볼 수 있는 연산자들을 살펴보자.

- === : 값의 일치를 판단
- instanceof : 객체의 클래스를 판단, 좌측 피연산자가 우측 피연산자의 인스턴스인지를 판단한다. 우측에는 반드시 생성자 함수 또는 클래스가 와야한다.(정확히는 호출 가능한 객체가 와야한다)
- in : 객체에 특정 프로퍼티가 있는지 확인, 우측에 반드시 객체가 와야한다.

- 비교 연산자 : 숫자(Number or BigInt)와 문자열의 순서만 비교가 가능.

<h4> 동등 연산자 </h4>

값의 동등함을 판단하는 연산자이다. js에서는 일반적인 동등 연산자(==)와 엄격한 동등 연산자(===)가 존재한다. 일반적인 동등 연산자는 타입이달라도 값이 같으면 동등하다고 평가한다. 동등 연산자에는 암시적 강제 변환을 허용하는데 연산 중에 내부적으로 타입을 변환해 연산을 수행하는 것을 의미한다.

엄격한 동등 연산자는 암시적 강제 변환을 허용하지 않는다. 엄격한 동등 연산의 결과가 동등이라면 당연히 일반적인 동등 연산자도 동등하다.

<h4> 할당 연산자 </h4>

할당 연산자는 변수에 값을 할당하는 연산자로, 좌측 피연산자는 반드시 **변수나 객체의 프로퍼티 혹은 배열의 원소처럼 값을 할당할 수 있는 요소** 중 하나가 와야함. (이러한 값을 l-value라고 한다)

<h4> typeof 연산자 </h4>

typeof 연산자는 피연산자의 타입을 문자열로 반환하는 단항 연산자이다.
- typeof null => 'object' 로 반환, 따라서 null 타입을 확인하고 싶다면 엄격한 동등 연산자를 사용해 확인해야한다. 또한 함수 외의 객체들은 모두 'object' 문자열을 반환해 정확하게 구분하지 못한다. 만약 객체의 클래스를 구분하고 싶다면 instanceof 를 사용해야 한다. 

<h4> 연산자 우선순위 </h4>

- AND 연산이 OR 연산보다 우선순위가 높다.

~~~
let x = 2, y;
y = x++, x;
console.log(y) // 2
~~~

쉼표 연산자는 마지막 평갓값을 반환한다고 하였지만 할당 연산자가 더 우선순위가 높아 2를 반환하였다. 우선순위를 변경하고 싶은 경우에는 괄호를 이용하자.




